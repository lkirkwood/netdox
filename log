FUNCTION LOAD REPLACE "#!lua name=netdox \n local function list_to_map(list)\n	local last_key = nil\n	local map = {}\n\n	for _, value in ipairs(list) do\n		if last_key == nil then\n			last_key = value\n		else\n			map[last_key] = value\n			last_key = nil\n		end\n	end\n\n	return map\nend\n\nlocal function map_to_list(map)\n	local list = {}\n	local index = 0\n\n	for key, value in pairs(map) do\n		index = index + 1\n		list[index] = key\n		index = index + 1\n		list[index] = value\n	end\n\n	return list\nend\n\nlocal function dns_names_to_node_id(names)\n	table.sort(names)\n	return table.concat(names, ';')\nend\n\nlocal DEFAULT_NETWORK_KEY = 'default_network'\nlocal NETWORK_PATTERN = '%[[%w_-]+%]'\n\nlocal function is_qualified(name)\n	local startindex, _ = string.find(name, NETWORK_PATTERN)\n	return startindex == 1\nend\n\nlocal function qualify_dns_name(name)\n	if is_qualified(name) then\n		return name\n	else\n		return string.format('[%s]%s', redis.call('GET', DEFAULT_NETWORK_KEY), name)\n	end\nend\n\nlocal function qualify_dns_names(names)\n	for i, name in pairs(names) do\n		names[i] = qualify_dns_name(name)\n	end\n	return names\nend\n\nlocal ADDRESS_RTYPES = { ['CNAME'] = true, ['A'] = true, ['PTR'] = true }\n\n\nlocal function create_change(change, value, plugin)\n	redis.call('XADD', 'changelog', '*', 'change', change, 'value', value, 'plugin', plugin)\nend\n\n\nlocal DNS_KEY = 'dns'\n\nlocal function create_dns(names, args)\n	local qname = qualify_dns_name(names[1])\n	local plugin, rtype, value = unpack(args)\n	local changed = false\n\n	if rtype ~= nil then\n		rtype = string.upper(rtype)\n	end\n\n	if redis.call('SADD', DNS_KEY, qname) ~= 0 then\n		create_change('create dns name', qname, plugin)\n		changed = true\n	end\n\n	local name_plugins = string.format('%s;%s;plugins', DNS_KEY, qname)\n	if redis.call('SADD', name_plugins, plugin) ~= 0 then\n		if not changed then\n			create_change('add plugin to dns name', name_plugins, plugin)\n			changed = true\n		end\n	end\n\n	if value ~= nil and rtype ~= nil then\n		local name_plugin_rtypes = string.format('%s;%s;%s', DNS_KEY, qname, plugin)\n		redis.call('SADD', name_plugin_rtypes, rtype)\n\n		if ADDRESS_RTYPES[rtype] then\n			value = qualify_dns_name(value)\n			create_dns({ value }, { plugin })\n		end\n\n		local value_set = string.format('%s;%s;%s;%s', DNS_KEY, qname, plugin, rtype)\n		if redis.call('SADD', value_set, value) ~= 0 then\n			if not changed then\n				create_change('create dns record', string.format('%s;%s', value_set, value), plugin)\n				changed = true\n			end\n		end\n	end\nend\n\nlocal function map_dns(names, args)\n	local origin = names[1]\n	local net_start, net_end = string.find(origin, NETWORK_PATTERN)\n	if net_start ~= 1 then\n		return 'Origin DNS name must be qualified with a network.'\n	end\n	local origin_name = string.sub(origin, net_end + 1)\n	local origin_net = string.sub(origin, net_start, net_end)\n\n	local plugin, reverse = table.remove(args, 1), table.remove(args, 1)\n	create_dns({ origin }, { plugin })\n\n	for _, dest in pairs(args) do\n		local _net_start, _net_end = string.find(dest, NETWORK_PATTERN)\n		if _net_start ~= 1 then\n			return 'Destination DNS name must be qualified with a network.'\n		end\n		local dest_net = string.sub(dest, _net_start, _net_end)\n		local dest_name = string.sub(dest, _net_end + 1)\n		create_dns({ dest }, { plugin })\n\n		local maps_key = string.format('%s;%s;maps', DNS_KEY, origin)\n		local old = redis.call('HGET', maps_key, dest_net)\n		if old ~= dest then\n			create_change('updated network mapping', maps_key, plugin)\n			redis.call('HSET', maps_key, dest_net, dest_name)\n		end\n\n		if reverse == 'true' then\n			map_dns({ dest }, { plugin, 'false', origin })\n		end\n	end\nend\n\n\nlocal NODES_KEY = 'nodes'\n\nlocal function create_node(dns_names, args)\n	local dns_qnames = qualify_dns_names(dns_names)\n\n	local plugin, name, exclusive, link_id = unpack(args)\n	exclusive = exclusive or 'false'\n\n	for _, qname in ipairs(dns_qnames) do\n		create_dns({ qname }, { plugin })\n	end\n\n	local node_id = string.format('%s;%s', dns_names_to_node_id(dns_qnames), plugin)\n	local node_key = string.format('%s;%s', NODES_KEY, node_id)\n	redis.call('SADD', NODES_KEY, node_id)\n\n	local node_count = tonumber(redis.call('GET', node_key))\n	if node_count == nil then\n		node_count = 0\n	end\n\n	for index = 1, node_count do\n		local details = list_to_map(redis.call('HGETALL', string.format('%s;%s', node_key, index)))\n		if details['name'] == name and details['exclusive'] == exclusive and details['link_id'] == link_id then\n			return\n		end\n	end\n\n	local index = redis.call('INCR', node_key)\n	local node_details = string.format('%s;%s', node_key, index)\n	if name ~= nil then\n		redis.call('HSET', node_details, 'name', name)\n	end\n	redis.call('HSET', node_details, 'exclusive', exclusive)\n	if link_id ~= nil then\n		redis.call('HSET', node_details, 'link_id', link_id)\n	end\n\n	create_change('create plugin node', node_id, plugin)\n\n	return node_details\nend\n\n\nlocal METADATA_KEY = 'meta'\n\nlocal function create_metadata(id, plugin, args)\n	redis.call('SADD', METADATA_KEY, id)\n	local meta_key = string.format('meta;%s', id)\n\n	local changed = false\n	for key, value in pairs(list_to_map(args)) do\n		local old_val = redis.call('HGET', meta_key, key)\n		if old_val ~= value then\n			changed = true\n			redis.call('HSET', meta_key, key, value)\n		end\n	end\n\n	if changed then\n		create_change('updated metadata', meta_key, plugin)\n	end\nend\n\nlocal function create_dns_metadata(names, args)\n	local qname = qualify_dns_name(names[1])\n	local plugin = table.remove(args, 1)\n\n	create_dns({ qname }, { plugin })\n	create_metadata(string.format('%s;%s', DNS_KEY, qname), plugin, args)\nend\n\nlocal function create_node_metadata(names, args)\n	local qnames = qualify_dns_names(names)\n	local plugin = table.remove(args, 1)\n\n	local node_id = string.format('%s;%s', dns_names_to_node_id(qnames), plugin)\n\n	if not redis.call('GET', string.format('%s;%s', NODES_KEY, node_id)) then\n		create_node(qnames, { plugin })\n	end\n\n	create_metadata(string.format('%s;%s', NODES_KEY, node_id), plugin, args)\nend\n\n\nlocal function create_data_str(data_key, plugin, title, content_type, content)\n	local details_key = string.format('%s;details', data_key)\n	redis.call('HSET', details_key, 'type', 'string')\n	redis.call('HSET', details_key, 'plugin', plugin)\n	redis.call('HSET', details_key, 'title', title)\n	redis.call('HSET', details_key, 'content_type', content_type)\n\n	if redis.call('GET', data_key) ~= content then\n		redis.call('SET', data_key, content)\n		create_change('updated plugin data', data_key, plugin)\n	end\nend\n\nlocal function create_data_hash(data_key, plugin, title, content)\n	if redis.call('TYPE', data_key) ~= 'hash' then\n		redis.call('DEL', data_key)\n	end\n\n	local details_key = string.format('%s;details', data_key)\n	redis.call('HSET', details_key, 'type', 'hash')\n	redis.call('HSET', details_key, 'plugin', plugin)\n	redis.call('HSET', details_key, 'title', title)\n\n	if redis.call('HGETALL', data_key) ~= content then\n		redis.call('DEL', data_key)\n		redis.call('HSET', data_key, unpack(content))\n		create_change('updated plugin data', data_key, plugin)\n	end\nend\n\nlocal function create_data_list(data_key, plugin, list_title, item_title, content)\n	if redis.call('TYPE', data_key) ~= 'list' then\n		redis.call('DEL', data_key)\n	end\n\n	local details_key = string.format('%s;details', data_key)\n	redis.call('HSET', details_key, 'type', 'list')\n	redis.call('HSET', details_key, 'plugin', plugin)\n	redis.call('HSET', details_key, 'list_title', list_title)\n	redis.call('HSET', details_key, 'item_title', item_title)\n\n	if redis.call('LRANGE', data_key, 0, -1) ~= content then\n		redis.call('DEL', data_key)\n		redis.call('LPUSH', data_key, unpack(content))\n		create_change('updated plugin data', data_key, plugin)\n	end\nend\n\n\nlocal PLUGIN_DATA_KEY = 'pdata'\n\nlocal function create_plugin_data_list(obj_key, pdata_id, plugin, args)\n	local list_title = table.remove(args, 1)\n	local item_title = table.remove(args, 1)\n\n	local data_key = string.format('%s;%s;%s', PLUGIN_DATA_KEY, obj_key, pdata_id)\nend\n\nlocal function create_plugin_data_hash(obj_key, pdata_id, plugin, args)\n	local title = table.remove(args, 1)\n	local data_key = string.format('%s;%s;%s', PLUGIN_DATA_KEY, obj_key, pdata_id)\n	create_data_hash(data_key, plugin, title, args)\nend\n\nlocal function create_plugin_data_str(obj_key, pdata_id, plugin, args)\n	local title = table.remove(args, 1)\n	local content_type = table.remove(args, 1)\n	local content = table.remove(args, 1)\n	local data_key = string.format('%s;%s;%s', PLUGIN_DATA_KEY, obj_key, pdata_id)\n	create_data_str(data_key, plugin, title, content_type, content)\nend\n\nlocal function create_plugin_data(obj_key, args)\n	local plugin = table.remove(args, 1)\n	local dtype = table.remove(args, 1)\n	local pdata_id = table.remove(args, 1)\n\n	if dtype == 'list' then\n		return create_plugin_data_list(obj_key, pdata_id, plugin, args)\n	elseif dtype == 'hash' then\n		return create_plugin_data_hash(obj_key, pdata_id, plugin, args)\n	elseif dtype == 'string' then\n		return create_plugin_data_str(obj_key, pdata_id, plugin, args)\n	else\n		return string.format('Invalid plugin data type: %s', tostring(dtype))\n	end\nend\n\nlocal function create_dns_plugin_data(names, args)\n	local qname = qualify_dns_name(names[1])\n	local plugin = args[1]\n\n	create_dns({ qname }, { plugin })\n	return create_plugin_data(string.format('%s;%s', DNS_KEY, qname), args)\nend\n\nlocal function create_node_plugin_data(names, args)\n	local qnames = qualify_dns_names(names)\n	local plugin = args[1]\n	local node_id = string.format('%s;%s', dns_names_to_node_id(qnames), plugin)\n\n	if not redis.call('GET', string.format('%s;%s', NODES_KEY, node_id)) then\n		create_node(qnames, { plugin })\n	end\n\n	return create_plugin_data(string.format('%s;%s', NODES_KEY, node_id), args)\nend\n\n\nlocal REPORTS_KEY = 'reports'\n\nlocal function create_report(_id, args)\n	local id = _id[1]\n	local plugin = table.remove(args, 1)\n	local title = table.remove(args, 1)\n	local data_key = string.format('%s;%s', REPORTS_KEY, id)\n	redis.call('HSET', data_key, {\n		length = 0,\n		plugin = plugin,\n		title = title,\n	})\nend\n\n\nredis.register_function('netdox_create_dns', create_dns)\nredis.register_function('netdox_map_dns', map_dns)\n\nredis.register_function('netdox_create_node', create_node)\n\nredis.register_function('netdox_create_dns_metadata', create_dns_metadata)\nredis.register_function('netdox_create_node_metadata', create_node_metadata)\n\nredis.register_function('netdox_create_dns_plugin_data', create_dns_plugin_data)\nredis.register_function('netdox_create_node_plugin_data', create_node_plugin_data)\n"
